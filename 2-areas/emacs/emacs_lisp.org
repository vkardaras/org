#+title: Emacs Lisp

* emacs basics
** Define a function

Define a function witn the =defun= keyword

#+begin_src elisp
(defun my-next-15-lines ()
  "Move to the next 15 lines."
  (interactive)
  (forward-line 15))

(defun my-previous-15-lines ()
  "Move to the next 15 lines."
  (interactive)
  (forward-line -15))

#+end_src

** Define key bindings for the custom commands

#+begin_src elisp
(define-key global-map (kbd "C-S-n") #'my-next-15-lines)

(define-key global-map (kbd "C-S-p") #'my-previous-15-lines)

#+end_src

** Define a variable

#+begin_src elisp
(defvar my-first-toggle t
  "if non-nil, do stuff.")
#+end_src

** Conditional statements

*** ~if~ statement

#+begin_src elisp
  (if my-first-toggle
      (message "It is true")
    (message "It is not true"))
#+end_src

#+begin_src elisp
  ;; Use `eval-expression' to evaluate this code in a file-visiting `test'
  ;; buffer versus a buffer that does not visit any file.
  (if buffer-file-name
      (message "The path to this file is `%s'" buffer-file-name)
    (message "Sorry mate, this buffer is not visiting a file"))
#+end_src

*** ~when~ and ~unless~

#+begin_src elisp
  ;; when statement
  (when t
    'this-is-true)

  ;; unless statement
  (unless nil
    'this-is-false)
#+end_src

*** ~progn~

Use it to perform a sequence of operations in an ~if~ expression

#+begin_src elisp
  (if t
      (progn
        (message "print this in minibuffger")
        'this-was-true)
    'this-was-false)
#+end_src

** Iteration

*** cl-loop
#+begin_src elisp
  (cl-loop for i from 0 to 10
           collect (* i i))
#+end_src

*** while
#+begin_src elisp
  (setq my/val 1)
  (setq my/truth t)
  (while my/truth
    (if (= my/val 10)
        (setq my/truth nil))
    (message "%s" (setq my/val (1+ my/val))))
#+end_src

*** dotimes
#+begin_src elisp
  (setq total nil)
  (dotimes (i 3)
    (setq total (cons total i)))
  total
#+end_src

*** dolist
#+begin_src elisp
  (setq total 0)
  (dolist (i '(1 2 3))
    (setq total (+ total i)))
  total
#+end_src

** hooks

A *hook* is a list of functions to run in a particular situation

#+begin_src elisp
  (defun my-fun ()
    (interactive)
    ;; does something
    (run-hooks 'my-fun-hook))

  (add-hook 'my-fun-hook (lambda () (insert "3")))
  (add-hook 'my-fun-hook (lambda () (insert "4")))
#+end_src

One example usecase would be to change settings for a particular programming language

#+begin_src elisp
  (add-hook 'emacs-lisp-mode-hook (lambda ()
                                    (indent-tabs-mode -1)))
#+end_src

** Temporary Variables ~let~

When you want a function local variable people usually use ~let~

#+begin_src elisp
  (defun what-is-2+2-5 ()
    (let (
          (four (+ 2 2))
          (five 5)
          )
      (- four five)))

  ;; call this function
  (what-is-2+2-5)
#+end_src

** Evaluate elisp code
=C-x C-e=

*** Open mini-buffer to evaluate elisp code
=M-:=

*** Evaluate elisp code in the scratch buffer and return the value of the expression
=C-j=

** Define a function with optional argument and conditional statement

#+begin_src elisp
(defun my-next-or-prev-15-lines (&optional arg)
  "Mov to the next or previous 15 lines.
With optional prefix ARG, move to the next lines. Else to the
previous ones."
  (interactive "P")
  (if arg
      (my-next-15-lines)
    (my-previous-15-lines)))
#+end_src

=(interactive "P")= represents the =C-u= prefix argument, which is the universal argument

* define prefix/leader key (nested key maps)

Define a function
#+begin_src elisp
(defun test-command ()
  (interactive)
  (message "this is a test"))
#+end_src

Create a key binding to call the function
#+begin_src elisp
  ;; from emacs 29 and above
  (keymap-set global-map "C-t" 'test-command)
  (keymap-global-set "C-t" 'test-command)
  ;; define keymap for specific mode e.g. `c programming language'
  (keymap-set c-mode-map "C-t" 'test-command)

  ;; before emacs 29
  (define-key global-map (kbd "C-t") 'test-command)
  (global-set-key (kbd "C-t") 'test-command)

  ;; define keybind in a package
  (use-package PACKAGE
    :bind ("C-t" . test-command))
  ;; define the map explicitely
  (use-package PACKAGE
    :bind (:map global-map
                ("C-t" . test-command)))
#+end_src

** Define and call a keymap

Define a sub-keymap
#+begin_src elisp
(defvar-keymap my-test-prefix-buffer-map
  :doc "My prefix map for buffers"
  "s" #'switch-to-buffer
  "b" #'buffer-menu)
#+end_src

Define a keymap
#+begin_src elisp
(defvar-keymap my-test-prefix-map
  :doc "My prefix map"
  "f" 'find-file
  "b" my-test-prefix-buffer-map
  "d" 'dired
  "t" 'test-command)
#+end_src

Call the keymap
#+begin_src elisp
(keymap-set global-map "C-t" my-test-prefix-map)
#+end_src

Set value for sub-keymap in which key
#+begin_src elisp
(which-key-add-keymap-based-replacements my-test-prefix-map
  "b" `("Buffer" . ,my-test-prefix-buffer-map))
#+end_src
